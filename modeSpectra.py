import numpy as np
from sympy import symbols, Eq, solve, Matrix
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
import nonLin_FPU as fpu
from scipy.fft import dst

def normalModes(N):
    """
    Compute the normal modal Fourier sine coefficients for the chain
    """
    k=0 
    modes=[]
    while k<=N:
        i=0 
        localModes=[]
        while i<=N:
            localModes.append(np.sqrt(2/(N+1))*np.sin((np.pi*k*i)/(N+1)))
            i+=1 
        modes.append(localModes)
        k+=1 
    return modes 

def modalSpectra(N, alpha, initConds, tMax, iters, nonLin=2):
    """
    Compute the modal spectrum of the FPU chain. Projects the displacement and momenta
    onto the normal mode basis. Transforms from time (t) domain into mode (k) domain. 
    """
    times, momenta, displacements = fpu.solverFunc(N,alpha, initConds, tMax, iters, nonLin)
    FTdisp = np.array(normalModes(N)) @ np.array(displacements)
    FTmom = np.array(normalModes(N)) @ np.array(momenta)
    return times, FTdisp, FTmom 

def plotSpectra(N, alpha, initConds, tMax, iters, nonLin=2):
    """
    Plot the modal spectrum of the FPU chain
    """
    print("Solver running...")
    times, FTdisp, FTmom  = modalSpectra(N, alpha, initConds, tMax, iters, nonLin)
    for i in range(N+1):
        plt.plot(times, FTdisp[i], label="Mode k="+str(i))
    if nonLin==2:
        plt.title(r"Modal Spectra for quadratic FPU problem, $\alpha=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
    else:
        plt.title(r"Modal Spectra for cubic FPU problem, $\beta=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
    plt.xlabel("Time")
    plt.ylabel("Modal spectrum")
    plt.legend(loc='upper right',  bbox_to_anchor=(1.129, 1))
    print("Solving complete. See output plot for results.")
    plt.show()
    return None

def exciteMode(N, k):
    """
    Generate inital conditions that excites mode k for a FPU chain of length N+1 (index from 0 to N => N+1 particles)
    Recall even entries are momenta and odd entries are displacements
    Using the initial conditions generated by this, the spectral plot should return a large amplitude of oscillation for mode k and small amplitudes for everything else
    """
    initConds=[]
    i=0 
    while i<2*(N+1):
        initConds.append(0)
        initConds.append(np.sqrt(2/(N+1))*np.sin((np.pi*k*(i//2))/(N+1)))
        i+=2 
    return initConds

def plotEnergies(N, alpha, initConds, tMax, iters, nonLin=2,plot=True):
    """
    Plot the spectral energies of the modes. Compute the energies in 
    accordance to the original FPU paper. 
    """
    print("Solver running...")
    times, FTdisp, FTmom = modalSpectra(N, alpha, initConds, tMax, iters, nonLin)
    k=0 
    energies=[]
    while k<N:
        localEnergies=0.5*FTmom[k]**2+ 2* (FTdisp[k]**2) *((np.pi*k)/(2*(N+1)))**2
        energies.append(localEnergies)
        if plot:
            plt.plot(times, localEnergies, label="Mode "+str(k))
        k+=1
    if plot:
        print("Solving complete. See output plot for results.")
        plt.legend(loc='upper right',  bbox_to_anchor=(1.129, 1))
        if nonLin==2:
            plt.title(r"Spectral Energies for quadratic FPU problem, $\alpha=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
        else:
            plt.title(r"Spectral Energies for cubic FPU problem, $\beta=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
        plt.xlabel("Time")
        plt.ylabel("Spectral Energy")
        plt.show()
    return times, energies

def plotEntropy(N, alpha, initConds, tMax, iters, nonLin):
    """
    Plot the Shannon entropy (how evenly energy is spread between modes) of the spectral energy
    """
    times, energies = plotEnergies(N, alpha, initConds, tMax, iters, nonLin, False)
    entropies=[]
    j=0
    while j<len(times):
        entropy=0 
        totalEnergy=0
        for energy in energies:
            totalEnergy+=energy[j]
        k=0 
        while k<N:
            if energies[k][j]==0 or totalEnergy==0:
                entropy+=0
            else:
                P=energies[k][j]/totalEnergy
                entropy+=(P)*np.log(P)
                #print("Total Energy=", totalEnergy, "|| Energy=", energies[k][j],"|| P=", P ,"|| entropy=", entropy)
            k+=1
        entropy=-np.array(entropy)/np.log(N+1)
        entropies.append(entropy)
    #    plt.plot(times[j],entropy, "o", color="black")
       # print(times[j],entropy)
        j+=1
    #print(times, entropies)
    print("Solving complete. See output plot for results.")
    if nonLin==2:
        plt.title(r"Normalised Shannon Entropy for quadratic FPU problem, $\alpha=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
    else:
        plt.title(r"Normalised Shannon Entropy for cubic FPU problem, $\beta=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
    plt.xlabel("Time")
    plt.axhline(y=1, color="red",label="S/lnN=1")
    plt.ylabel("Normalised Shannon Entropy (S/lnN)")
    plt.plot(times,entropies,color="black")
    plt.legend()
    plt.show()
    return times, entropies

plotEntropy(20, 1/6 , exciteMode(20,18), 5000000, 20000000, 2)
    
def terminalWizard():
    print("=== FPU Spectral Analyser ===")
    N=int(input("Enter the number of masses: "))-1
    nonLin=int(input("Enter the nonlinearity exponent (2 or 3): "))
    alpha=float(input("Enter the nonlinearity coefficient: "))
    custom= int(input("Enter 0 for custom initial conditions or 1 to Excite a mode: ")) 
    if custom==0:
        initConds=fpu.automaticInitialiser(N)
    else: 
        k=int(input("Enter the mode you want to excite: "))
        initConds=exciteMode(N,k)
    tMax=float(input("Enter the maximum simulation time: "))
    iters=int(input("Enter the maximum simulation timesteps: "))
    return plotSpectra(N,alpha,initConds,tMax, iters, nonLin)

def energyWizard():
    print("=== FPU Spectral Energy Analyser ===")
    N=int(input("Enter the number of masses: "))-1
    nonLin=int(input("Enter the nonlinearity exponent (2 or 3): "))
    alpha=float(input("Enter the nonlinearity coefficient: "))
    custom= int(input("Enter 0 for custom initial conditions or 1 to Excite a mode: ")) 
    if custom==0:
        initConds=fpu.automaticInitialiser(N)
    else: 
        k=int(input("Enter the mode you want to excite: "))
        initConds=exciteMode(N,k)
    tMax=float(input("Enter the maximum simulation time: "))
    iters=int(input("Enter the maximum simulation timesteps: "))
    return plotEnergies(N,alpha,initConds,tMax, iters, nonLin)

def entropyWizard():
    print("=== FPU Shannon Entropy Analyser ===")
    N=int(input("Enter the number of masses: "))-1
    nonLin=int(input("Enter the nonlinearity exponent (2 or 3): "))
    alpha=float(input("Enter the nonlinearity coefficient: "))
    custom= int(input("Enter 0 for custom initial conditions or 1 to Excite a mode: ")) 
    if custom==0:
        initConds=fpu.automaticInitialiser(N)
    else: 
        k=int(input("Enter the mode you want to excite: "))
        initConds=exciteMode(N,k)
    tMax=float(input("Enter the maximum simulation time: "))
    iters=int(input("Enter the maximum simulation timesteps: "))
    return plotEntropy(N,alpha,initConds,tMax, iters, nonLin)

#print(exciteMode(3,1))
#plotSpectra(3, 1/4 , [0,1.08,0,0.9,0,1.05,0,1.03], 10, 500000, 2)
#plotEnergies(32, 0.6 , exciteMode(32,1), 36000, 1000000, 2)
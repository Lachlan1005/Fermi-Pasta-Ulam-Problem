import numpy as np
from sympy import symbols, Eq, solve, Matrix
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
import nonLin_FPU as fpu
from scipy.fft import dst

def normalModes(N):
    """
    Compute the normal modal Fourier sine coefficients for the chain
    """
    k=0 
    modes=[]
    while k<=N:
        i=0 
        localModes=[]
        while i<=N:
            localModes.append(np.sqrt(2/N)*np.sin((np.pi*k*i)/N))
            i+=1 
        modes.append(localModes)
        k+=1 
    return modes 

def modalSpectra(N, alpha, initConds, tMax, iters, nonLin=2):
    """
    Compute the modal spectrum of the FPU chain
    """
    times, momenta, displacements = fpu.solverFunc(N,alpha, initConds, tMax, iters, nonLin)
    FTdisp = np.array(normalModes(N)) @ np.array(displacements)
    FTmom = np.array(normalModes(N)) @ np.array(momenta)
    return times, FTdisp, FTmom 

def plotSpectra(N, alpha, initConds, tMax, iters, nonLin=2):
    """
    Plot the modal spectrum of the FPU chain
    """
    times, FTdisp, FTmom  = modalSpectra(N, alpha, initConds, tMax, iters, nonLin)
    for i in range(N+1):
        plt.plot(times, FTdisp[i], label="Mode k="+str(i))
    if nonLin==2:
        plt.title(r"Modal Spectra for quadratic FPU problem, $\alpha=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
    else:
        plt.title(r"Modal Spectra for cubic FPU problem, $\beta=$"+ str(round(alpha*100)/100)+", N="+str(N)+" ("+str(N+1)+" masses)")
    plt.xlabel("Time (s)")
    plt.ylabel("Modal spectrum (1)")
    plt.legend()
    plt.show()
    return None

def exciteMode(N, k):
    """
    Generate inital conditions that excites mode k for a FPU chain of length N+1 (index from 0 to N => N+1 particles)
    Recall even entries are momenta and odd entries are displacements
    Using the initial conditions generated by this, the spectral plot should return a large amplitude of oscillation for mode k and small amplitudes for everything else
    """
    initConds=[]
    i=0 
    while i<2*(N+1):
        initConds.append(0)
        initConds.append(np.sqrt(2/N)*np.sin((np.pi*k*(i//2))/N))
        i+=2 
    return initConds

def terminalWizard():
    print("=== FPU Spectral Analyser ===")
    N=int(input("Enter the number of masses: ")-1)
    nonLin=int(input("Enter the nonlinearity exponent (2 or 3): "))
    alpha=int(input("Enter the nonlinearity coefficient: "))
    custom= int(input("Enter 0 for custom initial conditions or1 to Excite a mode ")) 
    if custom==0:
        initConds=fpu.automaticInitialiser(N)
    else: 
        k=int(input("Enter the mode you want to excite: "))
        initConds=exciteMode(N,k)
    tMax=float(input("Enter the maximum simulation time: "))
    iters=float(input("Enter the maximum simulation timesteps: "))
    return plotSpectra(N,alpha,initConds,tMax, iters, nonLin)

#print(exciteMode(3,1))
#plotSpectra(3, 1/4 , [0,1.08,0,0.9,0,1.05,0,1.03], 10, 500000, 2)
#plotSpectra(3, 1/4 , exciteMode(3,1), 30, 500000, 2)